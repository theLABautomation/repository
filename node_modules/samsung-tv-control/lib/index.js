"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = require("fs");
const net = require("net");
const path = require("path");
const request = require("request");
const wol = require("wake_on_lan");
const WebSocket = require("ws");
const keys_1 = require("./keys");
const logger_1 = require("./logger");
class Samsung {
    constructor(config) {
        this.TOKEN_FILE = path.join(__dirname, 'token.txt');
        if (!config.ip) {
            throw new Error('You must provide IP in config');
        }
        if (!config.mac) {
            throw new Error('You must provide MAC in config');
        }
        this.IP = config.ip;
        this.MAC = config.mac;
        this.PORT = Number(config.port) || 8002;
        this.TOKEN = config.token || '';
        this.NAME_APP = Buffer.from(config.nameApp || 'NodeJS Remote').toString('base64');
        this.SAVE_TOKEN = config.saveToken || false;
        this.APP_STRING = config.appString || 'iphone..iapp.samsung';
        this.TV_APP_STRING = config.tvAppString || 'iphone.UE40NU7400.iapp.samsung';
        this.LOGGER = new logger_1.default({ DEBUG_MODE: !!config.debug });
        this.LOGGER.log('config', config, 'constructor');
        this.WS_URL = `${this.PORT === 8001 ? 'ws' : 'wss'}://${this.IP}:${this.PORT}/api/v2/channels/samsung.remote.control?name=${this.NAME_APP}${this.TOKEN !== '' ? ` &token=${this.TOKEN}` : ''}`;
        if (this.SAVE_TOKEN) {
            try {
                fs.accessSync(this.TOKEN_FILE, fs.constants.F_OK);
                console.log('File suss!');
                const fileData = fs.readFileSync(this.TOKEN_FILE);
                this.TOKEN = fileData.toString();
            }
            catch (e) {
                console.log('File error!');
            }
        }
        this.LOGGER.log('internal config', {
            IP: this.IP,
            MAC: this.MAC,
            NAME_APP: this.NAME_APP,
            PORT: this.PORT,
            SAVE_TOKEN: this.SAVE_TOKEN,
            TOKEN: this.TOKEN,
            WS_URL: this.WS_URL
        }, 'constructor');
    }
    getToken(done) {
        this.LOGGER.log('getToken', '');
        if (this.SAVE_TOKEN && this.TOKEN !== 'null' && this.TOKEN !== '') {
            done(this.TOKEN);
            return;
        }
        this.sendKey(keys_1.KEYS.KEY_HOME, (err, res) => {
            if (err) {
                this.LOGGER.error('after sendKey', err, 'getToken');
                throw new Error(err);
            }
            else {
                const token = (res && res.data && res.data.token && res.data.token) || null;
                this.LOGGER.log('got token', token, 'getToken');
                this.TOKEN = token;
                if (this.SAVE_TOKEN) {
                    this._saveTokenToFile(token);
                }
                done(token);
            }
        });
    }
    getTokenPromise() {
        return new Promise((resolve, reject) => {
            this.LOGGER.log('getTokenPromise', '');
            if (this.SAVE_TOKEN && this.TOKEN !== 'null' && this.TOKEN !== '') {
                resolve(this.TOKEN);
                return;
            }
            this.sendKey(keys_1.KEYS.KEY_HOME, (err, res) => {
                if (err) {
                    this.LOGGER.error('after sendKey', err, 'getTokenPromise');
                    reject('after sendKey getTokenPromise');
                }
                else {
                    const token = (res && res.data && res.data.token && res.data.token) || null;
                    this.LOGGER.log('got token', token, 'getTokenPromise');
                    this.TOKEN = token;
                    if (this.SAVE_TOKEN) {
                        this._saveTokenToFile(token);
                    }
                    resolve(token);
                }
            });
        });
    }
    sendKey(key, done) {
        this.LOGGER.log('send key', key, 'sendKey');
        if (this.PORT === 55000) {
            this._sendLegacy(key, done);
        }
        else {
            this._send(this._getCommandByKey(key), done, 'ms.channel.connect');
        }
    }
    sendKeyPromise(key) {
        this.LOGGER.log('send key', key, 'sendKeyPromise');
        if (this.PORT === 55000) {
            return this._sendLegacyPromise(key);
        }
        else {
            return this._sendPromise(this._getCommandByKey(key), 'ms.channel.connect');
        }
    }
    getAppsFromTV(done) {
        return this._send({
            method: 'ms.channel.emit',
            params: {
                data: '',
                event: 'ed.installedApp.get',
                to: 'host'
            }
        }, done);
    }
    getAppsFromTVPromise() {
        return this._sendPromise({
            method: 'ms.channel.emit',
            params: {
                data: '',
                event: 'ed.installedApp.get',
                to: 'host'
            }
        });
    }
    openApp(appId, done) {
        this.getAppsFromTV((err, res) => {
            this.LOGGER.error('getAppsFromTV error', err, 'openApp getAppsFromTV');
            if (err || res.data.data === undefined) {
                this.LOGGER.error('getAppsFromTV error', err, 'openApp getAppsFromTV');
                return false;
            }
            const apps = res.data.data;
            const app = apps.find(appIter => appIter.appId === appId);
            if (!app) {
                this.LOGGER.error('This APP is not installed', { appId, app }, 'openApp getAppsFromTV');
                throw new Error('This APP is not installed');
            }
            this._send({
                method: 'ms.channel.emit',
                params: {
                    data: {
                        action_type: app.app_type === 2 ? 'DEEP_LINK' : 'NATIVE_LAUNCH',
                        appId: app.appId
                    },
                    event: 'ed.apps.launch',
                    to: 'host'
                }
            }, done);
        });
    }
    async openAppPromise(appId) {
        try {
            const res = await this.getAppsFromTVPromise();
            if (res && res.data && res.data.data === undefined) {
                this.LOGGER.error('getAppsFromTV res.data.data is undefined', '', 'openAppPromise getAppsFromTV');
                return false;
            }
            const apps = res.data.data;
            const app = apps.find(appIter => appIter.appId === appId);
            if (!app) {
                this.LOGGER.error('This APP is not installed', { appId, app }, 'openAppPromise getAppsFromTV');
                throw new Error('This APP is not installed');
            }
            return this._sendPromise({
                method: 'ms.channel.emit',
                params: {
                    data: {
                        action_type: app.app_type === 2 ? 'DEEP_LINK' : 'NATIVE_LAUNCH',
                        appId: app.appId
                    },
                    event: 'ed.apps.launch',
                    to: 'host'
                }
            });
        }
        catch (error) {
            this.LOGGER.error('getAppsFromTV error', error, 'openAppPromise getAppsFromTV');
            return false;
        }
    }
    isAvaliable() {
        return new Promise((resolve, reject) => {
            request.get({ url: `http://${this.IP}:8001${this.PORT === 55000 ? '/ms/1.0/' : '/api/v2/'}`, timeout: 3000 }, (err, res) => {
                if (!err && res.statusCode === 200) {
                    this.LOGGER.log('TV is avaliable', { request: res.request, body: res.body, code: res.statusCode }, 'isAvaliable');
                    resolve('TV is avaliable');
                }
                else {
                    this.LOGGER.error('TV is avaliable', { err }, 'isAvaliable');
                    reject('No response from TV');
                }
            });
        });
    }
    isAvaliablePing() {
        return new Promise((resolve, reject) => {
            child_process_1.exec('ping -c 1 -W 1 ' + this.IP, (error, stdout, stderr) => {
                if (error) {
                    this.LOGGER.error('TV is avaliable', { error }, 'isAvaliable');
                    reject('No response from TV');
                }
                else {
                    this.LOGGER.log('TV is avaliable', { stdout }, 'isAvaliable');
                    resolve('TV is avaliable');
                }
            });
        });
    }
    turnOn() {
        return new Promise((resolve, reject) => {
            wol.wake(this.MAC, { num_packets: 30 }, (err) => {
                if (err) {
                    this.LOGGER.error('Fail turn on', err, 'turnOn');
                    reject('Fail turn on');
                }
                else {
                    this.LOGGER.log('WOL sent command to TV', '', 'turnOn');
                    resolve('TV is avaliable');
                }
            });
        });
    }
    getLogs() {
        this.LOGGER.saveLogToFile();
    }
    _send(command, done, eventHandle) {
        const ws = new WebSocket(this.WS_URL, { rejectUnauthorized: false });
        this.LOGGER.log('command', command, '_send');
        this.LOGGER.log('wsUrl', this.WS_URL, '_send');
        ws.on('open', () => {
            if (this.PORT === 8001) {
                setTimeout(() => ws.send(JSON.stringify(command)), 1000);
            }
            else {
                ws.send(JSON.stringify(command));
            }
        });
        ws.on('message', (message) => {
            const data = JSON.parse(message);
            this.LOGGER.log('data: ', JSON.stringify(data, null, 2), 'ws.on message');
            if (done && (data.event === command.params.event || data.event === eventHandle)) {
                this.LOGGER.log('if correct event', 'callback triggered', 'ws.on message');
                done(null, data);
            }
            if (data.event !== 'ms.channel.connect') {
                this.LOGGER.log('if not correct event', 'ws is close', 'ws.on message');
                ws.close();
            }
        });
        ws.on('response', (response) => {
            this.LOGGER.log('response', response, 'ws.on response');
        });
        ws.on('error', (err) => {
            let errorMsg = '';
            if (err.code === 'EHOSTUNREACH' || err.code === 'ECONNREFUSED') {
                errorMsg = 'TV is off or unavalible';
            }
            console.error(errorMsg);
            this.LOGGER.error(errorMsg, err, 'ws.on error');
            if (done) {
                done(err, null);
            }
        });
    }
    _sendPromise(command, eventHandle) {
        return new Promise((resolve, reject) => {
            this._send(command, (err, res) => {
                if (!err) {
                    resolve(res);
                }
                else {
                    reject(err);
                }
            }, eventHandle);
        });
    }
    _getCommandByKey(key) {
        return {
            method: 'ms.remote.control',
            params: {
                Cmd: 'Click',
                DataOfCmd: key,
                Option: 'false',
                TypeOfRemote: 'SendRemoteKey'
            }
        };
    }
    _sendLegacyPromise(key) {
        return new Promise((resolve, reject) => {
            this._sendLegacy(key, (err, res) => {
                if (!err) {
                    resolve(res);
                }
                else {
                    reject(err);
                }
            });
        });
    }
    _sendLegacy(key, done) {
        if (!key) {
            this.LOGGER.error('send() missing command', { key });
            return;
        }
        this.LOGGER.log('send key', key, 'sendKey');
        const connection = net.connect(this.PORT, this.IP);
        connection.setTimeout(3000);
        connection.on('connect', () => {
            const payload = this.getLegacyCommand(key);
            connection.write(payload.header);
            connection.write(payload.command);
            connection.end();
            connection.destroy();
        });
        connection.on('close', () => {
            this.LOGGER.log('closed connection', {}, 'connection.on close');
        });
        connection.on('error', (err) => {
            let errorMsg = '';
            if (err.code === 'EHOSTUNREACH' || err.code === 'ECONNREFUSED') {
                errorMsg = 'Device is off or unreachable';
            }
            else {
                errorMsg = err.code;
            }
            console.error(errorMsg);
            this.LOGGER.error(errorMsg, err, 'connection.on error');
            if (done) {
                done(err, null);
            }
        });
        connection.on('timeout', (err) => {
            console.error('timeout');
            this.LOGGER.error('timeout', err, 'connection.on timeout');
            if (done) {
                done(err, null);
            }
        });
    }
    getLegacyCommand(key) {
        const payload = { header: '', command: '' };
        const headerData = this.chr(0x64) +
            this.chr(0x00) +
            this.chr(this.base64(this.IP).length) +
            this.chr(0x00) +
            this.base64(this.IP) +
            this.chr(this.base64(this.MAC).length) +
            this.chr(0x00) +
            this.base64(this.MAC) +
            this.chr(this.base64(this.NAME_APP).length) +
            this.chr(0x00) +
            this.base64(this.NAME_APP);
        payload.header =
            this.chr(0x00) +
                this.chr(this.APP_STRING.length) +
                this.chr(0x00) +
                this.APP_STRING +
                this.chr(headerData.length) +
                this.chr(0x00) +
                headerData;
        const commandData = this.chr(0x00) +
            this.chr(0x00) +
            this.chr(0x00) +
            this.chr(this.base64(key).length) +
            this.chr(0x00) +
            this.base64(key);
        payload.command =
            this.chr(0x00) +
                this.chr(this.TV_APP_STRING.length) +
                this.chr(0x00) +
                this.TV_APP_STRING +
                this.chr(commandData.length) +
                this.chr(0x00) +
                commandData;
        return payload;
    }
    chr(char) {
        return String.fromCharCode(char);
    }
    base64(str) {
        return Buffer.from(str).toString('base64');
    }
    _saveTokenToFile(token) {
        try {
            fs.accessSync(this.TOKEN_FILE, fs.constants.F_OK);
            console.log('File suss!');
            fs.writeFileSync(this.TOKEN_FILE, token);
        }
        catch (e) {
            console.log('File error!');
            fs.writeFileSync(this.TOKEN_FILE, token);
        }
    }
}
exports.default = Samsung;
//# sourceMappingURL=index.js.map