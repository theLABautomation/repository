"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const path = tslib_1.__importStar(require("path"));
const minimatch_1 = tslib_1.__importDefault(require("minimatch"));
const ts_lib_utils_1 = require("ts-lib-utils");
const checker_1 = require("./checker");
const dependencies_1 = require("./dependencies");
const ignore_1 = require("./ignore");
const cache_1 = require("./cache");
/**
 * @public
 */
async function lint(project, options) {
    const lintOptions = { ...defaultLintOptions, ...options };
    const { rootNames, compilerOptions } = await ts_lib_utils_1.getProjectRootNamesAndCompilerOptions(project);
    const program = typescript_1.default.createProgram(rootNames, compilerOptions, undefined, lintOptions.oldProgram);
    const checker = program.getTypeChecker();
    const allFiles = new Set();
    const sourceFileInfos = [];
    const typeCheckResult = await cache_1.readCache(lintOptions.enableCache);
    const ignoreFileGlobs = lintOptions.ignoreFiles
        ? (typeof lintOptions.ignoreFiles === 'string'
            ? [lintOptions.ignoreFiles]
            : lintOptions.ignoreFiles)
        : undefined;
    for (const sourceFile of program.getSourceFiles()) {
        let file = sourceFile.fileName;
        if (!file.includes('node_modules') && (!lintOptions.files || lintOptions.files.includes(file))) {
            if (!lintOptions.absolutePath) {
                file = path.relative(process.cwd(), file);
            }
            if (ignoreFileGlobs && ignoreFileGlobs.some((f) => minimatch_1.default(file, f))) {
                continue;
            }
            allFiles.add(file);
            const hash = await cache_1.getFileHash(file, lintOptions.enableCache);
            const cache = typeCheckResult.cache[file];
            sourceFileInfos.push({
                file,
                sourceFile,
                hash,
                cache: cache && cache.hash === hash ? cache : undefined
            });
        }
    }
    if (lintOptions.enableCache) {
        const dependencies = dependencies_1.collectDependencies(sourceFileInfos, allFiles);
        for (const sourceFileInfo of sourceFileInfos) {
            if (!sourceFileInfo.cache) {
                dependencies_1.clearCacheOfDependencies(sourceFileInfo, dependencies, sourceFileInfos);
            }
        }
    }
    let correctCount = 0;
    let totalCount = 0;
    const anys = [];
    const fileCounts = new Map();
    for (const { sourceFile, file, hash, cache } of sourceFileInfos) {
        if (cache) {
            correctCount += cache.correctCount;
            totalCount += cache.totalCount;
            anys.push(...cache.anys.map((a) => ({ file, ...a })));
            if (lintOptions.fileCounts) {
                fileCounts.set(file, {
                    correctCount: cache.correctCount,
                    totalCount: cache.totalCount,
                });
            }
            continue;
        }
        const ingoreMap = ignore_1.collectIgnoreMap(sourceFile, file);
        const context = {
            file,
            sourceFile,
            typeCheckResult: {
                correctCount: 0,
                totalCount: 0,
                anys: []
            },
            ignoreCatch: lintOptions.ignoreCatch,
            catchVariables: {},
            debug: lintOptions.debug,
            strict: lintOptions.strict,
            checker,
            ingoreMap
        };
        sourceFile.forEachChild(node => {
            checker_1.checkNode(node, context);
        });
        correctCount += context.typeCheckResult.correctCount;
        totalCount += context.typeCheckResult.totalCount;
        anys.push(...context.typeCheckResult.anys.map((a) => ({ file, ...a })));
        if (lintOptions.fileCounts) {
            fileCounts.set(file, {
                correctCount: context.typeCheckResult.correctCount,
                totalCount: context.typeCheckResult.totalCount
            });
        }
        if (lintOptions.enableCache) {
            const resultCache = typeCheckResult.cache[file];
            if (resultCache) {
                resultCache.hash = hash;
                resultCache.correctCount = context.typeCheckResult.correctCount;
                resultCache.totalCount = context.typeCheckResult.totalCount;
                resultCache.anys = context.typeCheckResult.anys;
            }
            else {
                typeCheckResult.cache[file] = {
                    hash,
                    ...context.typeCheckResult
                };
            }
        }
    }
    if (lintOptions.enableCache) {
        await cache_1.saveCache(typeCheckResult);
    }
    return { correctCount, totalCount, anys, program, fileCounts };
}
exports.lint = lint;
const defaultLintOptions = {
    debug: false,
    files: undefined,
    oldProgram: undefined,
    strict: false,
    enableCache: false,
    ignoreCatch: false,
    ignoreFiles: undefined,
    fileCounts: false,
};
